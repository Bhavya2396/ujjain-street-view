<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360¬∞ Street View - Smart Tagging</title>
    
    <!-- Favicon (inline to avoid 404) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üó∫Ô∏è</text></svg>">
    
    <!-- Leaflet (Free, no API key needed) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Three.js for 360 Video -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Turf.js for geospatial calculations -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #0d0d12;
            --bg-panel: #15151d;
            --accent-cyan: #00e5c7;
            --accent-magenta: #ff3366;
            --accent-blue: #3b82f6;
            --text-primary: #f0f0f5;
            --text-muted: #6e6e80;
            --border-subtle: rgba(255, 255, 255, 0.08);
            --glow-cyan: rgba(0, 229, 199, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        /* Login Screen */
        .login-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d0d12 0%, #1a1a2e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .login-container {
            background: var(--bg-panel);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            padding: 48px;
            max-width: 480px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .login-header {
            text-align: center;
            margin-bottom: 36px;
        }
        
        .login-logo {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }
        
        .login-header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .login-header p {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .login-form .form-group {
            margin-bottom: 20px;
        }
        
        .login-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
            color: var(--bg-dark);
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px var(--glow-cyan);
        }
        
        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px var(--glow-cyan);
        }
        
        .login-info {
            margin-top: 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
        }
        
        /* Matterport Modal */
        .matterport-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .matterport-modal.show {
            display: flex;
        }
        
        .matterport-container {
            width: 90vw;
            max-width: 1400px;
            height: 85vh;
            background: var(--bg-panel);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
        }
        
        .matterport-header {
            padding: 20px 24px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .matterport-header h3 {
            font-size: 18px;
            font-weight: 700;
            color: white;
            margin: 0;
        }
        
        .matterport-close {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .matterport-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .matterport-viewer {
            flex: 1;
            background: #000;
        }
        
        .matterport-viewer iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* Header */
        .header {
            height: 52px;
            background: linear-gradient(180deg, var(--bg-panel) 0%, rgba(21, 21, 29, 0.95) 100%);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-icon svg {
            width: 16px;
            height: 16px;
            fill: var(--bg-dark);
        }
        
        .logo-text {
            font-weight: 600;
            font-size: 15px;
            letter-spacing: -0.01em;
        }
        
        .header-divider {
            width: 1px;
            height: 20px;
            background: var(--border-subtle);
        }
        
        .header-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .header-info span {
            color: var(--accent-cyan);
        }
        
        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 52px);
        }
        
        /* Map Panel */
        .map-panel {
            width: 45%;
            position: relative;
            border-right: 1px solid var(--border-subtle);
        }
        
        #map {
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
        }
        
        /* Leaflet custom styles */
        .leaflet-container {
            background: #f5f5f5;
            font-family: 'Outfit', sans-serif;
        }
        
        .leaflet-tile-pane {
            filter: brightness(1.0) saturate(1.05);
        }
        
        .map-overlay {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(21, 21, 29, 0.92);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            padding: 14px 16px;
            z-index: 1000;
            max-width: 260px;
        }
        
        .map-overlay h3 {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }
        
        .map-overlay p {
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.5;
        }
        
        /* Stats Panel */
        .stats-panel {
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            background: rgba(21, 21, 29, 0.92);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            padding: 14px 16px;
            z-index: 1000;
            display: flex;
            gap: 20px;
        }
        
        .stat-item {
            flex: 1;
        }
        
        .stat-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .stat-value.highlight {
            color: var(--accent-cyan);
        }
        
        /* Video Panel */
        .video-panel {
            width: 55%;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
        }
        
        #video-container {
            flex: 1;
            position: relative;
            cursor: grab;
        }
        
        #video-container:active {
            cursor: grabbing;
        }
        
        #video-container canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* 3D Floating Markers in 360¬∞ Video */
        .marker-3d {
            position: absolute;
            pointer-events: auto;
            cursor: pointer;
            z-index: 50;
            transition: transform 0.2s ease;
        }
        
        .marker-3d:hover {
            transform: scale(1.15);
        }
        
        .marker-pin {
            width: 40px;
            height: 60px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .marker-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #ff3366, #ff6b9d);
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            box-shadow: 0 4px 12px rgba(255, 51, 102, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .marker-icon.hospital {
            background: linear-gradient(135deg, #ff3366, #ff0000);
        }
        
        .marker-icon.police {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }
        
        .marker-icon.landmark {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .marker-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
            transform: rotate(45deg);
        }
        
        .marker-pulse {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid;
            border-radius: 50%;
            animation: pulse-ring 2s ease-out infinite;
        }
        
        .marker-icon.hospital .marker-pulse {
            border-color: #ff3366;
        }
        
        .marker-icon.police .marker-pulse {
            border-color: #3b82f6;
        }
        
        .marker-icon.landmark .marker-pulse {
            border-color: #f59e0b;
        }
        
        @keyframes pulse-ring {
            0% {
                transform: scale(0.5) rotate(-45deg);
                opacity: 1;
            }
            100% {
                transform: scale(1.8) rotate(-45deg);
                opacity: 0;
            }
        }
        
        /* Pop-in animation for tags */
        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .marker-label {
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            margin-top: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.02em;
        }
        
        /* Info Popup */
        .marker-popup {
            position: absolute;
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            min-width: 220px;
            max-width: 300px;
            z-index: 100;
            pointer-events: auto;
            transform: translate(-50%, -120%);
            animation: popupAppear 0.3s ease;
        }
        
        @keyframes popupAppear {
            from {
                opacity: 0;
                transform: translate(-50%, -100%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -120%);
            }
        }
        
        .marker-popup::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid white;
        }
        
        .popup-header {
            font-weight: 700;
            font-size: 15px;
            color: #0d0d12;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .popup-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .popup-icon.hospital {
            background: #fee2e2;
        }
        
        .popup-icon.police {
            background: #dbeafe;
        }
        
        .popup-icon.landmark {
            background: #fef3c7;
        }
        
        .popup-icon svg {
            width: 14px;
            height: 14px;
        }
        
        .popup-icon.hospital svg {
            fill: #dc2626;
        }
        
        .popup-icon.police svg {
            fill: #2563eb;
        }
        
        .popup-icon.landmark svg {
            fill: #d97706;
        }
        
        .popup-details {
            font-size: 12px;
            color: #6b6b7b;
            line-height: 1.6;
        }
        
        .popup-distance {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e5e5e5;
            font-size: 11px;
            color: #3b82f6;
            font-weight: 600;
        }
        
        .matterport-btn {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .matterport-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.4);
        }
        
        .calibrate-btn {
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .calibrate-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }
        
        .calibration-mode {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 14px 20px;
            border-radius: 10px;
            z-index: 2000;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4);
            display: none;
        }
        
        .calibration-mode.active {
            display: block;
        }
        
        .calibration-mode button {
            margin-left: 12px;
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .calibration-mode button:first-of-type {
            background: white;
            color: #d97706;
        }
        
        .calibration-mode button:last-of-type {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .marker-3d.calibrating {
            cursor: move !important;
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px #f59e0b);
        }
        
        .popup-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border: none;
            background: #f5f5f5;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .popup-close:hover {
            background: #e5e5e5;
        }
        
        .popup-close::before,
        .popup-close::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 2px;
            background: #6b6b7b;
        }
        
        .popup-close::before {
            transform: rotate(45deg);
        }
        
        .popup-close::after {
            transform: rotate(-45deg);
        }
        
        /* Video Controls */
        .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            padding: 60px 20px 20px;
            z-index: 100;
        }
        
        .progress-container {
            margin-bottom: 16px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .progress-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-muted);
        }
        
        .progress-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .progress-bar-wrapper {
            height: 6px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }
        
        .progress-bar-wrapper:hover {
            height: 8px;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue));
            border-radius: 3px;
            transition: width 0.1s ease;
            width: 0%;
            position: relative;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: var(--accent-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--glow-cyan);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .progress-bar-wrapper:hover .progress-bar::after {
            opacity: 1;
        }
        
        .controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .control-btn svg {
            width: 18px;
            height: 18px;
            fill: var(--text-primary);
        }
        
        .control-btn.play-btn {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
        }
        
        .control-btn.play-btn:hover {
            box-shadow: 0 0 20px var(--glow-cyan);
        }
        
        .control-btn.play-btn svg {
            fill: var(--bg-dark);
        }
        
        /* Drag instruction */
        .drag-hint {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(21, 21, 29, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            color: var(--text-muted);
            z-index: 100;
        }
        
        .drag-hint svg {
            width: 14px;
            height: 14px;
            fill: var(--accent-cyan);
            vertical-align: middle;
            margin-right: 6px;
        }
        
        /* Add Landmark Button */
        .add-landmark-btn {
            position: absolute;
            top: 16px;
            left: 16px;
            background: linear-gradient(135deg, #34a853, #2d8e47);
            border: none;
            border-radius: 10px;
            padding: 12px 18px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
            transition: all 0.2s;
        }
        
        .add-landmark-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(52, 168, 83, 0.4);
        }
        
        .add-landmark-btn:active {
            transform: translateY(0);
        }
        
        /* Landmark Form Modal */
        .landmark-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .landmark-modal.show {
            display: flex;
        }
        
        .landmark-form {
            background: white;
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .form-header {
            font-size: 18px;
            font-weight: 700;
            color: #0d0d12;
            margin-bottom: 16px;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #6b6b7b;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e5e5e5;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Outfit', sans-serif;
            transition: border-color 0.2s;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #34a853;
        }
        
        .form-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e5e5e5;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Outfit', sans-serif;
            cursor: pointer;
        }
        
        .form-info {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
            border-radius: 8px;
            padding: 10px;
            font-size: 11px;
            color: #1e40af;
            margin-bottom: 16px;
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .form-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .form-btn.primary {
            background: linear-gradient(135deg, #34a853, #2d8e47);
            color: white;
        }
        
        .form-btn.primary:hover {
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
        }
        
        .form-btn.secondary {
            background: #f5f5f5;
            color: #6b6b7b;
        }
        
        .form-btn.secondary:hover {
            background: #e5e5e5;
        }
        
        /* Custom Leaflet marker */
        .position-marker {
            width: 20px;
            height: 20px;
            background: var(--accent-magenta);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(255, 51, 102, 0.5);
        }
        
        .start-marker {
            background: var(--accent-cyan);
            box-shadow: 0 2px 10px var(--glow-cyan);
        }
        
        .end-marker {
            background: var(--accent-magenta);
            box-shadow: 0 2px 10px rgba(255, 51, 102, 0.5);
        }
        
        /* Landmark markers on map */
        .landmark-map-marker {
            width: 32px;
            height: 32px;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .landmark-map-marker svg {
            width: 16px;
            height: 16px;
            fill: white;
            transform: rotate(45deg);
        }
        
        .landmark-map-marker.hospital {
            background: linear-gradient(135deg, #ff3366, #ff0000);
        }
        
        .landmark-map-marker.police {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }
        
        .landmark-map-marker.landmark {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .landmark-map-marker.cafe {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
        }
        
        /* Landmark visible in current video frame */
        .landmark-map-marker.visible-in-video {
            opacity: 1;
            transform: rotate(-45deg) scale(1.3);
            box-shadow: 0 4px 20px rgba(0, 229, 199, 0.6);
            border-color: var(--accent-cyan);
            animation: pulse-visible 2s ease-in-out infinite;
        }
        
        @keyframes pulse-visible {
            0%, 100% { box-shadow: 0 4px 20px rgba(0, 229, 199, 0.6); }
            50% { box-shadow: 0 6px 30px rgba(0, 229, 199, 0.9); }
        }
        
        /* Landmark nearby but not in current view */
        .landmark-map-marker.nearby {
            opacity: 0.85;
            transform: rotate(-45deg) scale(1.1);
        }
        
        /* Map landmark label */
        .landmark-map-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
            pointer-events: none;
            display: none;
        }
        
        .landmark-map-marker:hover .landmark-map-label {
            display: block;
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: var(--bg-panel);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 12px;
            color: var(--text-primary);
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 229, 199, 0.2);
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .toast.toast-success {
            background: linear-gradient(135deg, #34a853, #2d8e47);
            border-color: #34a853;
            box-shadow: 0 4px 20px rgba(52, 168, 83, 0.3);
        }
        
        .toast.toast-error {
            background: linear-gradient(135deg, #ff3366, #d72953);
            border-color: #ff3366;
            box-shadow: 0 4px 20px rgba(255, 51, 102, 0.3);
        }
        
        .toast.toast-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-color: #f59e0b;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.3);
        }
        
        .toast.toast-info {
            background: var(--bg-panel);
            border-color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 229, 199, 0.2);
        }
        
        /* Loading state */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.4s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-subtle);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 14px;
            font-size: 13px;
            color: var(--text-muted);
        }
    </style>
</head>
<body>
    <!-- Police Login Screen -->
    <div class="login-screen" id="loginScreen">
        <div class="login-container">
            <div class="login-header">
                <div class="login-logo">
                    <svg width="60" height="60" viewBox="0 0 24 24" fill="none">
                        <path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z" fill="url(#grad1)"/>
                        <defs>
                            <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#1d4ed8;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
                <h1>Police Sector Training System</h1>
                <p>360¬∞ Street View with Virtual Building Tours</p>
            </div>
            
            <div class="login-form">
                <div class="form-group">
                    <label class="form-label">üëÆ Officer Name</label>
                    <input type="text" class="form-input" id="officerName" placeholder="Enter your name" autocomplete="name">
                </div>
                
                <div class="form-group">
                    <label class="form-label">üîë Sector Key</label>
                    <select class="form-select" id="sectorKey">
                        <option value="">Select your sector...</option>
                        <option value="sector1">Sector 1 - Freeganj Area</option>
                        <option value="sector2">Sector 2 - Madhav Nagar</option>
                        <option value="sector3">Sector 3 - Mahakal Marg</option>
                        <option value="sector4">Sector 4 - University Road</option>
                        <option value="sector5">Sector 5 - Dewas Road (Current)</option>
                    </select>
                </div>
                
                <button class="login-btn" onclick="enterSector()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
                        <path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"/>
                    </svg>
                    Enter Sector Training
                </button>
                
                <div class="login-info">
                    <small>üîí Secure training environment ‚Ä¢ Real GPS routes ‚Ä¢ 3D building tours</small>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Header -->
    <header class="header" id="mainHeader" style="display: none;">
        <div class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 24 24">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>
            </div>
            <span class="logo-text">StreetView360</span>
        </div>
        <div class="header-divider"></div>
        <div class="header-info">
            Mode: <span>Click-to-Tag</span> | Route: <span>Gurgaon (Real GPS)</span> | Tags: <span id="tag-count">0</span>
        </div>
    </header>
    
    <!-- Matterport 3D Tour Modal -->
    <div class="matterport-modal" id="matterportModal">
        <div class="matterport-container">
            <div class="matterport-header">
                <h3 id="matterportTitle">Building Interior - 3D Tour</h3>
                <button class="matterport-close" onclick="closeMatterport()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
            <div class="matterport-viewer" id="matterportViewer">
                <!-- Matterport iframe loads here -->
            </div>
        </div>
    </div>
    
    <!-- Main Container -->
    <div class="main-container" id="mainContainer" style="display: none;">
        <!-- Map Panel -->
        <div class="map-panel">
            <div id="map"></div>
            
            <div class="map-overlay">
                <h3>Click-to-Tag Mode</h3>
                <p><strong>Click:</strong> Auto-fetch name from OpenStreetMap<br>
                <strong>Shift+Click:</strong> Enter name manually<br>
                <br>
                Tags appear instantly in the 360¬∞ video!</p>
            </div>
            
            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-label">Position</div>
                    <div class="stat-value highlight" id="stat-position">0.0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value" id="stat-distance">0 m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Route Length</div>
                    <div class="stat-value" id="stat-total">-- m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">üè∑Ô∏è Tags</div>
                    <div class="stat-value" id="stat-markers">
                        <span id="stat-markers-visible">0</span>/<span id="stat-markers-total">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video Panel -->
        <div class="video-panel">
            <div id="video-container">
                <div class="drag-hint">
                    <svg viewBox="0 0 24 24"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"/></svg>
                    Drag to look around ‚Ä¢ Click markers for info
                </div>
                
                <!-- Simple Instructions -->
                <div style="
                    position: absolute;
                    top: 16px;
                    left: 16px;
                    background: rgba(21, 21, 29, 0.95);
                    backdrop-filter: blur(12px);
                    border: 1px solid var(--border-subtle);
                    border-radius: 10px;
                    padding: 14px 18px;
                    color: white;
                    font-size: 13px;
                    z-index: 100;
                    max-width: 280px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                ">
                    <div style="font-weight: 600; color: var(--accent-cyan); margin-bottom: 8px;">
                        üëÜ Click-to-Tag Mode
                    </div>
                    <div style="font-size: 12px; line-height: 1.5; color: var(--text-muted);">
                        <strong>Click</strong> building ‚Üí Auto-fetch name from OSM<br>
                        <strong>Shift+Click</strong> ‚Üí Enter name manually
                    </div>
                </div>
                
                <!-- Clear Tags Button -->
                <button class="clear-tags-btn" id="clearTagsBtn" title="Clear all tagged landmarks" style="
                    position: absolute;
                    top: 120px;
                    left: 16px;
                    background: linear-gradient(135deg, #ef4444, #dc2626);
                    border: none;
                    border-radius: 10px;
                    padding: 10px 16px;
                    color: white;
                    font-size: 12px;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    z-index: 100;
                    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
                    transition: all 0.2s;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(239, 68, 68, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.3)'">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="white">
                        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                    </svg>
                    <span>Clear All</span>
                </button>
            </div>
            
            <div class="video-controls">
                <div class="progress-container">
                    <div class="progress-header">
                        <span class="progress-label">Video Progress</span>
                        <span class="progress-time" id="progress-time">00:00 / 00:00</span>
                    </div>
                    <div class="progress-bar-wrapper" id="progress-wrapper">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                </div>
                
                <div class="controls-row">
                    <button class="control-btn play-btn" id="play-btn" title="Play/Pause">
                        <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                        <svg id="pause-icon" viewBox="0 0 24 24" style="display: none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    </button>
                    <button class="control-btn" id="restart-btn" title="Restart">
                        <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                    </button>
                </div>
            </div>
            
            <div class="loading-overlay" id="video-loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading 360¬∞ video...</div>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>
    
    <!-- Calibration Mode Banner -->
    <div class="calibration-mode" id="calibrationMode">
        üéØ Drag the marker to its correct position
        <button onclick="saveCalibration()">Save Position</button>
        <button onclick="cancelCalibration()">Cancel</button>
    </div>
    
    <!-- Debug Overlay (Toggle with 'D' key) -->
    <div id="debugOverlay" style="
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.85);
        color: #0ff;
        padding: 15px;
        border-radius: 8px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        line-height: 1.6;
        z-index: 1500;
        display: none;
        border: 1px solid #0ff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        max-width: 350px;
    ">
        <div style="font-weight: bold; color: #fff; margin-bottom: 10px; border-bottom: 1px solid #0ff; padding-bottom: 5px;">
            üîç MARKER POSITIONING DEBUG
        </div>
        <div id="debugContent" style="color: #0ff;">
            Press 'D' to toggle this overlay
        </div>
    </div>
            
    
    <!-- Hidden video element -->
    <video id="video" style="display: none;" crossorigin="anonymous" playsinline loop preload="auto">
        <source src="VID_20251210_123710_00_001_003_DASHCAM1.mp4" type="video/mp4">
    </video>
    
    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        
        // Sector configuration
        const SECTOR_DATA = {
            sector1: {
                name: 'Sector 1 - Freeganj Area',
                routeFile: 'routes/sector1_route.json',
                videoFile: 'videos/sector1.mp4',
                description: 'Freeganj commercial area patrol route'
            },
            sector2: {
                name: 'Sector 2 - Madhav Nagar',
                routeFile: 'routes/sector2_route.json',
                videoFile: 'videos/sector2.mp4',
                description: 'Madhav Nagar residential area'
            },
            sector3: {
                name: 'Sector 3 - Mahakal Marg',
                routeFile: 'routes/sector3_route.json',
                videoFile: 'videos/sector3.mp4',
                description: 'Mahakal Temple vicinity'
            },
            sector4: {
                name: 'Sector 4 - University Road',
                routeFile: 'routes/sector4_route.json',
                videoFile: 'videos/sector4.mp4',
                description: 'University area patrol'
            },
            sector5: {
                name: 'Sector 5 - Dewas Road',
                routeFile: 'route.json', // Current demo route
                videoFile: 'VID_20251210_123710_00_001_003_DASHCAM1.mp4', // Current demo video
                description: 'Golf Course Extension Road (Gurgaon)',
                landmarks: {
                    'intellion_park': {
                        name: 'Intellion Park',
                        matterportUrl: 'https://my.matterport.com/show/?m=hwzo9nUjCMP'
                    }
                }
            }
        };
        
        // Current session
        let currentSector = null;
        let currentOfficer = null;
        
        // Will be loaded from route.json (Real GPS data from your Insta360 video!)
        let routeCoordinates = [];
        let routeGeoJSON = null;
        let routeTimestamps = []; // GPS timestamps for accurate sync
        
        // ============================================
        // GLOBAL VARIABLES
        // ============================================
        
        let map;
        let routeLine;
        let positionMarker;
        let totalRouteLength = 0;
        let mapLandmarkMarkers = []; // Landmarks on the map
        
        // Three.js variables
        let scene, camera, renderer;
        let videoTexture, videoMesh;
        let isUserInteracting = false;
        let onPointerDownMouseX = 0, onPointerDownMouseY = 0;
        let lon = 180, onPointerDownLon = 180; // Start facing forward (180¬∞ rotation)
        let lat = 0, onPointerDownLat = 0;
        let phi = 0, theta = 0;
        
        // Video element
        const video = document.getElementById('video');
        
        // 3D Markers data - Will be populated by auto-tagging
        // Start with empty markers array - use Click-to-Tag to add buildings!
        const markers3D = [];
        
        // System to add more landmarks easily
        let customMarkers = [];
        
        // Debug function to check marker status
        window.debugMarkers = function() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üîç MARKER DEBUG INFO');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log(`Total markers in markers3D array: ${markers3D.length}`);
            console.log(`Total marker elements in DOM: ${markerElements.length}`);
            console.log(`Total map markers: ${mapLandmarkMarkers.length}`);
            
            if (markers3D.length > 0) {
                console.log('\nüìã Marker List:');
                markers3D.forEach((m, i) => {
                    console.log(`${i + 1}. ${m.name}`);
                    console.log(`   ID: ${m.id}`);
                    console.log(`   GPS: ${m.lat.toFixed(6)}, ${m.lng.toFixed(6)}`);
                    console.log(`   Video Time: ${m.videoTime.toFixed(1)}s`);
                    console.log(`   Type: ${m.type}`);
                });
            } else {
                console.log('\n‚ùå No markers found!');
                console.log('üí° Tip: Click on a building on the map to tag it!');
            }
            
            const currentPos = getCurrentGPSPosition();
            if (currentPos) {
                console.log('\nüìç Current Position:');
                console.log(`   GPS: ${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}`);
                console.log(`   Video Time: ${video.currentTime.toFixed(2)}s / ${video.duration.toFixed(2)}s`);
                console.log(`   Heading: ${getCurrentHeading().toFixed(1)}¬∞`);
                console.log(`   Camera Yaw: ${lon.toFixed(1)}¬∞`);
                
                if (markers3D.length > 0) {
                    console.log('\nüìè Distances to Markers:');
                    markers3D.forEach((m, i) => {
                        const dist = calculateDistance(currentPos.lat, currentPos.lng, m.lat, m.lng);
                        const visible = dist <= 200;
                        console.log(`${i + 1}. ${m.name}: ${dist.toFixed(1)}m ${visible ? '‚úÖ In range' : '‚ùå Too far'}`);
                    });
                }
            }
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        };
        
        // Load custom markers from localStorage
        function loadCustomMarkers() {
            const saved = localStorage.getItem('customMarkers');
            if (saved) {
                try {
                    customMarkers = JSON.parse(saved);
                    customMarkers.forEach(marker => markers3D.push(marker));
                    console.log(`‚úÖ Loaded ${customMarkers.length} custom markers`);
                } catch (e) {
                    console.error('Error loading custom markers:', e);
                }
            }
        }
        
        function saveCustomMarkers() {
            localStorage.setItem('customMarkers', JSON.stringify(customMarkers));
        }
        
        // Store marker elements
        const markerElements = [];
        
        // ============================================
        // LOAD GPS DATA FROM FILE
        // ============================================
        
        async function loadGPSData() {
            try {
                const response = await fetch('route.json');
                if (!response.ok) {
                    throw new Error('Failed to load GPS data');
                }
                
                const data = await response.json();
                routeGeoJSON = data.features[0];
                
                // Convert to Leaflet format [lat, lng]
                routeCoordinates = routeGeoJSON.geometry.coordinates.map(c => [c[1], c[0]]);
                
                // Extract timestamps and convert to seconds since start
                const times = routeGeoJSON.properties.times;
                if (times && times.length > 0) {
                    const startTime = new Date(times[0]);
                    routeTimestamps = times.map(t => {
                        const time = new Date(t);
                        return (time - startTime) / 1000; // Seconds since start
                    });
                    
                    const gpsDuration = routeTimestamps[routeTimestamps.length - 1];
                    console.log(`‚úÖ GPS Duration: ${gpsDuration.toFixed(1)}s (${Math.floor(gpsDuration/60)}m ${Math.round(gpsDuration%60)}s)`);
                    console.log(`‚úÖ GPS Start: ${times[0]}`);
                    console.log(`‚úÖ GPS End: ${times[times.length - 1]}`);
                } else {
                    console.warn('‚ö†Ô∏è No timestamps found in GPS data, will use linear interpolation');
                    routeTimestamps = [];
                }
                
                console.log(`‚úÖ Loaded ${routeCoordinates.length} GPS points from real Insta360 video`);
                return true;
            } catch (error) {
                console.error('Error loading GPS data:', error);
                alert('Could not load GPS data. Using demo route.');
                
                // Fallback to demo route
                routeCoordinates = [
                    [28.4130, 77.1165],
                    [28.4100, 77.1063]
                ];
                routeGeoJSON = {
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'LineString',
                        coordinates: routeCoordinates.map(c => [c[1], c[0]])
                    }
                };
                return false;
            }
        }
        
        // ============================================
        // INITIALIZE MAP (Leaflet - Free, no API key)
        // ============================================
        
        function initMap() {
            // Calculate center
            const centerLat = routeCoordinates.reduce((sum, c) => sum + c[0], 0) / routeCoordinates.length;
            const centerLng = routeCoordinates.reduce((sum, c) => sum + c[1], 0) / routeCoordinates.length;
            
            // Initialize map
            map = L.map('map', {
                center: [centerLat, centerLng],
                zoom: 16,
                zoomControl: true
            });
            
            // Add detailed tile layer with buildings and POIs
            // Option 1: OpenStreetMap with labels (shows buildings, POIs, landmarks)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);
            
            // Uncomment for Mapbox (better visuals, requires free API key):
            // L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=YOUR_TOKEN', {
            //     attribution: '&copy; <a href="https://www.mapbox.com/">Mapbox</a>',
            //     tileSize: 512,
            //     zoomOffset: -1,
            //     maxZoom: 20
            // }).addTo(map);
            
            // Calculate total route length using Turf.js
            totalRouteLength = turf.length(routeGeoJSON, { units: 'meters' });
            document.getElementById('stat-total').textContent = `${Math.round(totalRouteLength)} m`;
            
            // Add route line (Google Maps style - bright green)
            // Shadow/outline (darker)
            L.polyline(routeCoordinates, {
                color: '#1a8f5c',
                weight: 10,
                opacity: 0.6,
                lineCap: 'round',
                lineJoin: 'round'
            }).addTo(map);
            
            // Main line (bright green like Google Maps)
            routeLine = L.polyline(routeCoordinates, {
                color: '#34a853',
                weight: 6,
                opacity: 0.95,
                lineCap: 'round',
                lineJoin: 'round'
            }).addTo(map);
            
            // Add click handler to route line for video seeking
            routeLine.on('click', function(e) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üõ£Ô∏è  ROUTE LINE CLICKED');
                console.log(`   Clicked coordinates: ${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // Stop event from bubbling to map click handler
                L.DomEvent.stopPropagation(e);
                
                // Find nearest point on route
                const clickedPoint = turf.point([e.latlng.lng, e.latlng.lat]);
                const nearestPoint = turf.nearestPointOnLine(routeGeoJSON, clickedPoint, { units: 'meters' });
                
                console.log('   Nearest point on route:', {
                    coordinates: nearestPoint.geometry.coordinates,
                    distanceFromClick: nearestPoint.properties.dist.toFixed(2) + 'm',
                    locationFraction: nearestPoint.properties.location.toFixed(4)
                });
                
                // Calculate percentage along route
                const distanceFraction = nearestPoint.properties.location; // 0-1 range
                const percentage = distanceFraction * 100;
                const distanceAlongRoute = distanceFraction * totalRouteLength;
                
                console.log('   Route position:', {
                    percentage: percentage.toFixed(2) + '%',
                    distanceAlongRoute: distanceAlongRoute.toFixed(1) + 'm',
                    totalRouteLength: totalRouteLength.toFixed(1) + 'm'
                });
                
                // Validate
                if (isNaN(percentage) || percentage < 0 || percentage > 100) {
                    console.error('‚ùå Invalid percentage calculated:', percentage);
                    showToast('‚ùå Error calculating position', 'error');
                    return;
                }
                
                // Check if video is ready
                if (!video || !video.duration || isNaN(video.duration)) {
                    console.warn('‚ö†Ô∏è Video not ready yet');
                    showToast('‚ö†Ô∏è Video loading... please wait', 'warning');
                    return;
                }
                
                // Seek video
                console.log(`   Seeking to ${percentage.toFixed(1)}% of video duration (${video.duration.toFixed(2)}s)`);
                seekVideo(percentage);
                
                // Pause video to let user see the location
                setTimeout(() => {
                    video.pause();
                }, 100);
                
                showToast(`üé¨ Jumped to ${percentage.toFixed(1)}% of route`, 'success');
            });
            
            // Add start marker
            const startIcon = L.divIcon({
                className: 'custom-marker',
                html: '<div class="position-marker start-marker"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            L.marker(routeCoordinates[0], { icon: startIcon })
                .bindPopup('<b>Start</b>')
                .addTo(map);
            
            // Add end marker
            const endIcon = L.divIcon({
                className: 'custom-marker',
                html: '<div class="position-marker end-marker"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            L.marker(routeCoordinates[routeCoordinates.length - 1], { icon: endIcon })
                .bindPopup('<b>End</b>')
                .addTo(map);
            
            // Create position marker (initially at start)
            const posIcon = L.divIcon({
                className: 'custom-marker',
                html: '<div class="position-marker" style="background: #ff3366; animation: pulse 1.5s ease-in-out infinite;"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            positionMarker = L.marker(routeCoordinates[0], { icon: posIcon, zIndexOffset: 1000 }).addTo(map);
            
            // Add CSS for pulse animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0%, 100% { transform: scale(1); box-shadow: 0 2px 10px rgba(255, 51, 102, 0.5); }
                    50% { transform: scale(1.2); box-shadow: 0 2px 20px rgba(255, 51, 102, 0.8); }
                }
            `;
            document.head.appendChild(style);
            
            // Fit bounds
            map.fitBounds(routeLine.getBounds(), { padding: [60, 60] });
            
            // Add click handler for the map
            map.on('click', handleMapClick);
        }
        
        // ============================================
        // MAP LANDMARKS SYSTEM
        // ============================================
        
        function addLandmarksToMap() {
            // Clear existing map markers
            mapLandmarkMarkers.forEach(marker => map.removeLayer(marker.leafletMarker));
            mapLandmarkMarkers = [];
            
            // Add each landmark to the map
            markers3D.forEach(marker => {
                addSingleLandmarkToMap(marker);
            });
            
            console.log(`‚úÖ Added ${mapLandmarkMarkers.length} landmarks to map`);
        }
        
        function addSingleLandmarkToMap(marker) {
            // Icon SVGs for different types
            const icons = {
                hospital: '<path d="M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4v4z"/>',
                police: '<path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"/>',
                landmark: '<path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zm0 18.5c-4.05-1.01-7-5.08-7-9.83V8.3l7-3.11 7 3.11v2.37c0 4.75-2.95 8.82-7 9.83z"/>',
                cafe: '<path d="M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zm0 5h-2V5h2v3zM4 19h16v2H4z"/>'
            };
            
            // Create custom map marker
            const markerIcon = L.divIcon({
                className: 'custom-landmark-marker',
                html: `
                    <div class="landmark-map-marker ${marker.type}" data-marker-id="${marker.id}">
                        <svg viewBox="0 0 24 24">${icons[marker.type] || icons.landmark}</svg>
                        <div class="landmark-map-label">${marker.name}</div>
                    </div>
                `,
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32]
            });
            
            // Create Leaflet marker
            const leafletMarker = L.marker([marker.lat, marker.lng], { 
                icon: markerIcon,
                zIndexOffset: 500 
            }).addTo(map);
            
            // Add popup with Matterport link if available
            const matterportBtn = marker.matterportUrl ? `
                <button onclick="openMatterport('${marker.id}', '${marker.name}', '${marker.matterportUrl}')" style="
                    margin-top: 8px;
                    padding: 6px 12px;
                    background: linear-gradient(135deg, #8b5cf6, #6d28d9);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 600;
                    width: 100%;
                ">
                    üè¢ View Interior (3D Tour)
                </button>
            ` : '';
            
            leafletMarker.bindPopup(`
                <div style="font-family: 'Outfit', sans-serif;">
                    <strong style="font-size: 14px;">${marker.name}</strong><br>
                    <span style="font-size: 11px; color: #666;">${marker.description || marker.type}</span><br>
                    ${matterportBtn}
                    <button onclick="jumpToLandmark('${marker.id}')" style="
                        margin-top: 8px;
                        padding: 6px 12px;
                        background: linear-gradient(135deg, #00e5c7, #3b82f6);
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 600;
                        width: 100%;
                    ">
                        üé¨ Jump to Video
                    </button>
                </div>
            `);
            
            // Store reference
            mapLandmarkMarkers.push({
                id: marker.id,
                leafletMarker: leafletMarker,
                data: marker
            });
        }
        
        function updateMapLandmarksVisibility() {
            if (!video.duration || mapLandmarkMarkers.length === 0) return;
            
            const currentPos = getCurrentGPSPosition();
            if (!currentPos) return;
            
            const currentHeading = getCurrentHeading();
            const cameraYaw = lon; // Current camera rotation
            
            mapLandmarkMarkers.forEach(({ leafletMarker, data }) => {
                // Calculate distance from current position
                const distance = calculateDistance(
                    currentPos.lat, currentPos.lng,
                    data.lat, data.lng
                );
                
                // Get the marker element
                const markerElement = leafletMarker.getElement();
                if (!markerElement) return;
                
                const markerDiv = markerElement.querySelector('.landmark-map-marker');
                if (!markerDiv) return;
                
                // Update marker state based on proximity
                markerDiv.classList.remove('visible-in-video', 'nearby');
                
                // Only show markers within 200m (matching video marker visibility)
                if (distance <= 200) {
                    // Calculate bearing to landmark
                    const bearing = calculateBearing(
                        currentPos.lat, currentPos.lng,
                        data.lat, data.lng
                    );
                    
                    // Calculate relative bearing (accounting for vehicle heading)
                    let relativeBearing = bearing - currentHeading;
                    while (relativeBearing > 180) relativeBearing -= 360;
                    while (relativeBearing < -180) relativeBearing += 360;
                    
                    // Check if landmark is in camera's field of view (wider 240¬∞ range)
                    const adjustedBearing = relativeBearing - cameraYaw;
                    const isInCameraView = Math.abs(adjustedBearing) < 120;
                    
                    if (isInCameraView) {
                        // Visible in current video frame
                        markerDiv.classList.add('visible-in-video');
                    } else {
                        // Nearby but not in current view
                        markerDiv.classList.add('nearby');
                    }
                } else {
                    // Too far - fade out on map
                    markerDiv.style.opacity = '0.3';
                }
            });
        }
        
        function jumpToLandmark(markerId) {
            console.log('üé¨ Jump to landmark:', markerId);
            
            // Find the marker
            const marker = markers3D.find(m => m.id === markerId);
            if (!marker) {
                console.error('‚ùå Marker not found:', markerId);
                showToast('‚ùå Marker not found');
                return;
            }
            
            // Check if video is ready
            if (!video.duration || isNaN(video.duration) || !totalRouteLength) {
                console.warn('‚ö†Ô∏è Video or route not ready yet');
                showToast('‚ö†Ô∏è Video loading... try again');
                return;
            }
            
            // Calculate timestamp based on marker's GPS location
            const landmarkPoint = turf.point([marker.lng, marker.lat]);
            const nearestPoint = turf.nearestPointOnLine(routeGeoJSON, landmarkPoint, { units: 'meters' });
            
            // nearestPoint.properties.location is a FRACTION (0 to 1) of total route length
            // Convert directly to percentage
            const distanceFraction = nearestPoint.properties.location; // 0-1 range
            const percentage = distanceFraction * 100; // Convert to 0-100 percentage
            const distanceAlongRoute = distanceFraction * totalRouteLength; // Distance in meters for logging
            
            // Validate percentage
            if (isNaN(percentage) || percentage < 0 || percentage > 100) {
                console.error('‚ùå Invalid percentage calculated:', percentage);
                console.log('   Distance along route:', distanceAlongRoute, 'meters');
                console.log('   Total route length:', totalRouteLength, 'meters');
                showToast('‚ùå Could not calculate position');
                return;
            }
            
            console.log(`üìç Jumping to: ${marker.name}`);
            console.log(`   Distance along route: ${distanceAlongRoute.toFixed(1)}m / ${totalRouteLength.toFixed(1)}m`);
            console.log(`   Position: ${percentage.toFixed(1)}%`);
            console.log(`   Video time: ${(percentage / 100 * video.duration).toFixed(2)}s / ${video.duration.toFixed(2)}s`);
            
            // Seek video
            seekVideo(percentage);
            
            // Pause video to let user see the location
            setTimeout(() => {
                video.pause();
            }, 100);
            
            // Show success with distance info
            const distance = Math.round(nearestPoint.properties.dist);
            showToast(`üé¨ Jumped to ${marker.name} (${distance}m from route)`, 'success');
        }
        
        // Make jumpToLandmark available globally for onclick
        window.jumpToLandmark = jumpToLandmark;
        
        // ============================================
        // POLICE LOGIN SYSTEM
        // ============================================
        
        function enterSector() {
            const officerName = document.getElementById('officerName').value.trim();
            const sectorKey = document.getElementById('sectorKey').value;
            
            if (!officerName) {
                alert('‚ö†Ô∏è Please enter your name');
                document.getElementById('officerName').focus();
                return;
            }
            
            if (!sectorKey) {
                alert('‚ö†Ô∏è Please select your sector');
                document.getElementById('sectorKey').focus();
                return;
            }
            
            // Store session
            currentOfficer = officerName;
            currentSector = sectorKey;
            
            // Save to localStorage
            localStorage.setItem('currentOfficer', officerName);
            localStorage.setItem('currentSector', sectorKey);
            
            // Show welcome message
            showToast(`üëÆ Welcome, ${officerName}! Loading ${SECTOR_DATA[sectorKey].name}...`);
            
            // Hide login, show app
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('mainHeader').style.display = 'flex';
            document.getElementById('mainContainer').style.display = 'flex';
            
            // Update header with officer info
            const headerInfo = document.querySelector('.header-info');
            if (headerInfo) {
                headerInfo.innerHTML = `
                    Mode: <span>Click-to-Tag</span> | 
                    Sector: <span>${SECTOR_DATA[sectorKey].name}</span> | 
                    Officer: <span>${officerName}</span> | 
                    Tags: <span id="tag-count">0</span>
                `;
            }
            
            console.log(`‚úÖ Officer ${officerName} entered ${SECTOR_DATA[sectorKey].name}`);
        }
        
        // Make enterSector available globally
        window.enterSector = enterSector;
        
        // ============================================
        // MATTERPORT 3D TOUR INTEGRATION
        // ============================================
        
        function openMatterport(markerId, buildingName, matterportUrl) {
            console.log(`üè¢ Opening Matterport for: ${buildingName}`);
            
            // Pause video
            video.pause();
            
            // Set title
            document.getElementById('matterportTitle').textContent = `${buildingName} - 3D Interior Tour`;
            
            // Load Matterport iframe
            const viewer = document.getElementById('matterportViewer');
            viewer.innerHTML = `
                <iframe 
                    src="${matterportUrl}" 
                    frameborder="0" 
                    allowfullscreen 
                    allow="autoplay; fullscreen; web-share; xr-spatial-tracking; gyroscope; accelerometer"
                    style="width: 100%; height: 100%;">
                </iframe>
            `;
            
            // Show modal
            document.getElementById('matterportModal').classList.add('show');
            
            showToast(`üè¢ Loading ${buildingName} 3D interior...`);
        }
        
        function closeMatterport() {
            // Hide modal
            document.getElementById('matterportModal').classList.remove('show');
            
            // Clear iframe to stop video/audio
            setTimeout(() => {
                document.getElementById('matterportViewer').innerHTML = '';
            }, 300);
            
            showToast('Returned to street view');
        }
        
        // ESC key to close Matterport
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('matterportModal');
                if (modal && modal.classList.contains('show')) {
                    closeMatterport();
                }
            }
        });
        
        // Make functions available globally
        window.openMatterport = openMatterport;
        window.closeMatterport = closeMatterport;
        
        // ============================================
        // UTILITIES
        // ============================================
        
        function updateTagCount() {
            const count = markers3D.length;
            const countEl = document.getElementById('tag-count');
            if (countEl) {
                countEl.textContent = count;
            }
        }
        
        // ============================================
        // CLICK-TO-TAG SYSTEM
        // ============================================
        
        async function createManualTag(lat, lng, buildingName) {
            console.log(`‚úèÔ∏è Manual tag: ${buildingName} at ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
            
            try {
                // Calculate nearest point on route
                const buildingPoint = turf.point([lng, lat]);
                const nearestPoint = turf.nearestPointOnLine(routeGeoJSON, buildingPoint, { units: 'meters' });
                const distanceFromRoute = nearestPoint.properties.dist;
                
                // Calculate video timestamp
                const distanceFromStart = nearestPoint.properties.location * totalRouteLength;
                const videoTime = (distanceFromStart / totalRouteLength) * video.duration;
                
                // Calculate bearing
                const nearestCoords = nearestPoint.geometry.coordinates;
                const bearing = calculateBearing(nearestCoords[1], nearestCoords[0], lat, lng);
                
                // Determine side
                const routeIndex = Math.floor(nearestPoint.properties.location * routeGeoJSON.properties.headings.length);
                const vehicleHeading = routeGeoJSON.properties.headings[routeIndex] || 0;
                let relativeBearing = bearing - vehicleHeading;
                while (relativeBearing > 180) relativeBearing -= 360;
                while (relativeBearing < -180) relativeBearing += 360;
                const side = relativeBearing > 0 ? 'right' : 'left';
                
                // Create marker
                const newMarker = {
                    id: `manual_${Date.now()}`,
                    type: 'landmark',
                    name: buildingName,
                    description: 'Manually Tagged',
                    lat: lat,
                    lng: lng,
                    bearing: bearing,
                    videoTime: videoTime,
                    side: side,
                    distance: Math.round(distanceFromRoute),
                    source: 'Manual Entry',
                    tags: {}
                };
                
                // Add to arrays
                markers3D.push(newMarker);
                customMarkers.push(newMarker);
                
                // Create 3D marker in video
                createSingleMarker(newMarker);
                
                // Add to map
                addSingleLandmarkToMap(newMarker);
                
                // Save
                saveCustomMarkers();
                
                // Update tag count
                updateTagCount();
                
                // Show success
                showToast(`‚úÖ Manually tagged: ${buildingName}`, 'success');
                console.log('‚úÖ Manual tag created:', newMarker);
                
            } catch (error) {
                console.error('‚ùå Error creating manual tag:', error);
                showToast('‚ùå Could not create tag. Try again.', 'error');
            }
        }
        
        
        async function handleMapClick(e) {
            // Don't tag if clicking on markers or route line
            if (e.originalEvent && e.originalEvent.target) {
                const target = e.originalEvent.target;
                // Check if click was on a marker or the route line
                if (target.closest('.leaflet-marker-icon') || 
                    target.closest('.leaflet-interactive')) {
                    console.log('üö´ Click was on a marker or route line, ignoring for tagging');
                    return;
                }
            }
            
            const clickedLat = e.latlng.lat;
            const clickedLng = e.latlng.lng;
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìç MAP BACKGROUND CLICKED (Building Tag Mode)');
            console.log(`   Coordinates: ${clickedLat.toFixed(6)}, ${clickedLng.toFixed(6)}`);
            console.log(`   Shift key: ${e.originalEvent.shiftKey}`);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Check if Shift key is held - force manual entry
            if (e.originalEvent.shiftKey) {
                const manualName = prompt('‚úèÔ∏è Manual Tagging\n\nEnter building name:');
                
                if (!manualName || manualName.trim() === '') {
                    showToast('‚ùå Tagging cancelled');
                    return;
                }
                
                console.log(`‚úèÔ∏è Manual tag: ${manualName}`);
                await createManualTag(clickedLat, clickedLng, manualName.trim());
                return;
            }
            
            // Show loading indicator
            const loadingMarker = L.marker([clickedLat, clickedLng], {
                icon: L.divIcon({
                    className: 'loading-marker',
                    html: '<div style="background: rgba(139, 92, 246, 0.8); padding: 8px 12px; border-radius: 8px; color: white; font-size: 11px; font-weight: 600; white-space: nowrap; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üîç Searching...</div>',
                    iconAnchor: [50, 40]
                })
            }).addTo(map);
            
            try {
                // Query OpenStreetMap for building at this location
                const radius = 20; // 20 meter radius around click
                const query = `
                [out:json][timeout:10];
                (
                  way["building"]["name"](around:${radius},${clickedLat},${clickedLng});
                  node["building"]["name"](around:${radius},${clickedLat},${clickedLng});
                  way["amenity"]["name"](around:${radius},${clickedLat},${clickedLng});
                  node["amenity"]["name"](around:${radius},${clickedLat},${clickedLng});
                );
                out center;
                `;
                
                // Try first server
                const response = await fetch('https://overpass.kumi.systems/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                
                if (!response.ok) throw new Error('Query failed');
                
                const data = await response.json();
                
                // Remove loading marker
                map.removeLayer(loadingMarker);
                
                if (!data.elements || data.elements.length === 0) {
                    // No building found - offer manual entry
                    map.removeLayer(loadingMarker);
                    
                    const manualName = prompt('‚ö†Ô∏è No building found in OpenStreetMap.\n\nEnter building name manually (or cancel):');
                    
                    if (!manualName || manualName.trim() === '') {
                        showToast('‚ùå Tagging cancelled');
                        return;
                    }
                    
                    // Create manual tag
                    await createManualTag(clickedLat, clickedLng, manualName.trim());
                    return;
                }
                
                // Get the closest building
                const building = data.elements[0];
                
                // Get coordinates
                let lat, lon;
                if (building.type === 'node') {
                    lat = building.lat;
                    lon = building.lon;
                } else if (building.center) {
                    lat = building.center.lat;
                    lon = building.center.lon;
                } else {
                    showToast('‚ö†Ô∏è Could not get building coordinates');
                    return;
                }
                
                // Get building name
                const buildingName = building.tags.name || 'Unnamed Building';
                
                // Determine type
                let type = 'landmark';
                let description = building.tags.building || 'Building';
                
                if (building.tags.amenity === 'hospital' || building.tags.building === 'hospital') {
                    type = 'hospital';
                    description = 'Hospital';
                } else if (building.tags.amenity === 'police') {
                    type = 'police';
                    description = 'Police Station';
                } else if (building.tags.amenity === 'cafe' || building.tags.amenity === 'restaurant') {
                    type = 'cafe';
                    description = building.tags.amenity || 'Food & Beverage';
                }
                
                // Calculate nearest point on route
                const buildingPoint = turf.point([lon, lat]);
                const nearestPoint = turf.nearestPointOnLine(routeGeoJSON, buildingPoint, { units: 'meters' });
                const distanceFromRoute = nearestPoint.properties.dist;
                
                // Check if too far from route
                if (distanceFromRoute > 300) {
                    if (!confirm(`‚ö†Ô∏è This building is ${Math.round(distanceFromRoute)}m from your route.\n\nTag it anyway?`)) {
                        return;
                    }
                }
                
                // Calculate video timestamp
                const distanceFromStart = nearestPoint.properties.location * totalRouteLength;
                const videoTime = (distanceFromStart / totalRouteLength) * video.duration;
                
                // Calculate bearing
                const nearestCoords = nearestPoint.geometry.coordinates;
                const bearing = calculateBearing(nearestCoords[1], nearestCoords[0], lat, lon);
                
                // Determine side
                const routeIndex = Math.floor(nearestPoint.properties.location * routeGeoJSON.properties.headings.length);
                const vehicleHeading = routeGeoJSON.properties.headings[routeIndex] || 0;
                let relativeBearing = bearing - vehicleHeading;
                while (relativeBearing > 180) relativeBearing -= 360;
                while (relativeBearing < -180) relativeBearing += 360;
                const side = relativeBearing > 0 ? 'right' : 'left';
                
                // Create marker
                const newMarker = {
                    id: `clicked_${Date.now()}`,
                    type: type,
                    name: buildingName,
                    description: description,
                    lat: lat,
                    lng: lon,
                    bearing: bearing,
                    videoTime: videoTime,
                    side: side,
                    distance: Math.round(distanceFromRoute),
                    source: 'Click-to-Tag',
                    tags: building.tags
                };
                
                // Add to arrays
                markers3D.push(newMarker);
                customMarkers.push(newMarker);
                
                console.log('üì¶ Adding marker to system...');
                console.log('   Total markers:', markers3D.length);
                
                // Create 3D marker in video
                console.log('   Creating 3D marker...');
                createSingleMarker(newMarker);
                
                // Add to map
                console.log('   Adding to map...');
                addSingleLandmarkToMap(newMarker);
                
                // Save
                console.log('   Saving to localStorage...');
                saveCustomMarkers();
                
                // Update tag count
                updateTagCount();
                
                // Show success
                showToast(`‚úÖ Tagged: ${buildingName}`, 'success');
                console.log('‚úÖ Successfully tagged building:', newMarker);
                
            } catch (error) {
                try {
                    map.removeLayer(loadingMarker);
                } catch (e) {
                    // Marker already removed
                }
                console.error('‚ùå Error tagging building:', error);
                showToast('‚ùå Could not tag building. Try again.', 'error');
            }
        }
        
        // ============================================
        // INITIALIZE THREE.JS 360 VIDEO
        // ============================================
        
        function init360Video() {
            const container = document.getElementById('video-container');
            
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 1, 1100);
            camera.target = new THREE.Vector3(0, 0, 0);
            
            // Create sphere geometry (inverted for inside viewing)
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1); // Flip inside-out
            
            // Video texture
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBFormat;
            
            // Material
            const material = new THREE.MeshBasicMaterial({ map: videoTexture });
            
            // Mesh
            videoMesh = new THREE.Mesh(geometry, material);
            scene.add(videoMesh);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Event listeners for interaction
            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerup', onPointerUp);
            container.addEventListener('wheel', onWheel);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Video events
            video.addEventListener('loadstart', () => {
                console.log('Video load started');
            });
            
            video.addEventListener('loadedmetadata', () => {
                console.log('Video metadata loaded. Duration:', video.duration, 'Ready state:', video.readyState);
            });
            
            video.addEventListener('loadeddata', () => {
                console.log('Video data loaded. Ready state:', video.readyState);
                document.getElementById('video-loading').classList.add('hidden');
                updateProgress();
                
                // Initialize 3D markers after video loads
                setTimeout(() => {
                    create3DMarkers();
                    startMarkerUpdates();
                    addLandmarksToMap(); // Add landmarks to map
                    console.log('‚úÖ 3D markers initialized');
                }, 1000);
            });
            
            video.addEventListener('canplay', () => {
                console.log('Video can play. Ready state:', video.readyState);
            });
            
            video.addEventListener('canplaythrough', () => {
                console.log('Video can play through. Ready state:', video.readyState);
            });
            
            video.addEventListener('timeupdate', () => {
                updateProgress();
                updateMarkerFromVideo();
                updateMapLandmarksVisibility(); // Sync map landmarks with video
            });
            
            video.addEventListener('seeked', () => {
                console.log('Video seeked to:', video.currentTime);
            });
            
            video.addEventListener('seeking', () => {
                console.log('Video seeking to:', video.currentTime);
            });
            
            video.addEventListener('error', (e) => {
                console.error('Video error:', e, video.error);
                document.getElementById('video-loading').innerHTML = `
                    <div style="color: #ff3366; font-size: 14px; text-align: center;">
                        Error loading video.<br>
                        <span style="font-size: 12px; color: #6e6e80;">Make sure Street2.mp4 is in the same folder.</span>
                    </div>
                `;
            });
            
            // Force video to start loading
            console.log('Initializing video. Ready state:', video.readyState);
            if (video.readyState === 0) {
                console.log('Loading video...');
                video.load();
            }
            
            // Start animation loop
            animate();
        }
        
        function onPointerDown(event) {
            isUserInteracting = true;
            onPointerDownMouseX = event.clientX;
            onPointerDownMouseY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
        }
        
        function onPointerMove(event) {
            if (!isUserInteracting) return;
            
            lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
            lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
        }
        
        function onPointerUp() {
            isUserInteracting = false;
        }
        
        function onWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = THREE.MathUtils.clamp(fov, 30, 90);
            camera.updateProjectionMatrix();
        }
        
        function onWindowResize() {
            const container = document.getElementById('video-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Clamp latitude
            lat = Math.max(-85, Math.min(85, lat));
            
            // Convert to radians
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);
            
            // Update camera target
            camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
            camera.target.y = 500 * Math.cos(phi);
            camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
            
            camera.lookAt(camera.target);
            renderer.render(scene, camera);
        }
        
        // ============================================
        // VIDEO CONTROLS
        // ============================================
        
        function setupVideoControls() {
            const playBtn = document.getElementById('play-btn');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const restartBtn = document.getElementById('restart-btn');
            const progressWrapper = document.getElementById('progress-wrapper');
            
            // Play/Pause
            playBtn.addEventListener('click', () => {
                if (video.paused) {
                    video.play();
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'block';
                } else {
                    video.pause();
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                }
            });
            
            // Update button on video play/pause events
            video.addEventListener('play', () => {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            });
            
            video.addEventListener('pause', () => {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            });
            
            // Restart
            restartBtn.addEventListener('click', () => {
                video.currentTime = 0;
            });
            
            // Progress bar click to seek
            progressWrapper.addEventListener('click', (e) => {
                const rect = progressWrapper.getBoundingClientRect();
                const percentage = ((e.clientX - rect.left) / rect.width) * 100;
                seekVideo(percentage);
            });
        }
        
        function updateProgress() {
            const currentTime = video.currentTime || 0;
            const duration = video.duration || 0;
            
            // Update time display
            document.getElementById('progress-time').textContent = 
                `${formatTime(currentTime)} / ${formatTime(duration)}`;
            
            // Update progress bar
            const percentage = duration > 0 ? (currentTime / duration) * 100 : 0;
            document.getElementById('progress-bar').style.width = `${percentage}%`;
            
            // Update stats
            document.getElementById('stat-position').textContent = `${percentage.toFixed(1)}%`;
            const distance = (percentage / 100) * totalRouteLength;
            document.getElementById('stat-distance').textContent = `${Math.round(distance)} m`;
        }
        
        function updateMarkerFromVideo() {
            if (!video.duration || isNaN(video.duration)) return;
            
            const percentage = video.currentTime / video.duration;
            
            // Calculate point along the route using Turf.js
            const alongDistance = percentage * totalRouteLength;
            const alongPoint = turf.along(routeGeoJSON, alongDistance, { units: 'meters' });
            
            if (alongPoint && positionMarker) {
                const coords = alongPoint.geometry.coordinates;
                positionMarker.setLatLng([coords[1], coords[0]]); // [lat, lng]
            }
        }
        
        // ============================================
        // 3D MARKER SYSTEM
        // ============================================
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                    Math.cos(œÜ1) * Math.cos(œÜ2) *
                    Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }
        
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
            const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                    Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360; // Normalize to 0-360
        }
        
        function getCurrentGPSPosition() {
            // Get current position from video playback using timestamp-based sync
            if (!video.duration || !routeCoordinates.length) return null;
            
            let index;
            
            // If we have GPS timestamps, use them for accurate sync
            if (routeTimestamps && routeTimestamps.length > 0) {
                // Map video time to GPS time
                const gpsDuration = routeTimestamps[routeTimestamps.length - 1];
                const videoTime = video.currentTime;
                
                // Find the GPS point that corresponds to current video time
                // Assuming video duration matches GPS duration
                const gpsTime = (videoTime / video.duration) * gpsDuration;
                
                // Find the two GPS points to interpolate between
                for (let i = 0; i < routeTimestamps.length - 1; i++) {
                    if (gpsTime >= routeTimestamps[i] && gpsTime <= routeTimestamps[i + 1]) {
                        // Linear interpolation between points
                        const t1 = routeTimestamps[i];
                        const t2 = routeTimestamps[i + 1];
                        const fraction = (gpsTime - t1) / (t2 - t1);
                        
                        // Interpolate coordinates
                        const lat1 = routeCoordinates[i][0];
                        const lng1 = routeCoordinates[i][1];
                        const lat2 = routeCoordinates[i + 1][0];
                        const lng2 = routeCoordinates[i + 1][1];
                        
                        return {
                            lat: lat1 + (lat2 - lat1) * fraction,
                            lng: lng1 + (lng2 - lng1) * fraction,
                            heading: getCurrentHeading(),
                            gpsIndex: i,
                            interpolation: fraction
                        };
                    }
                }
                
                // If we're past the end, use last point
                index = routeTimestamps.length - 1;
            } else {
                // Fallback to linear distribution if no timestamps
                const progress = video.currentTime / video.duration;
                index = Math.floor(progress * (routeCoordinates.length - 1));
            }
            
            if (index >= 0 && index < routeCoordinates.length) {
                return {
                    lat: routeCoordinates[index][0],
                    lng: routeCoordinates[index][1],
                    heading: getCurrentHeading(),
                    gpsIndex: index
                };
            }
            return null;
        }
        
        function getCurrentHeading() {
            // Get vehicle heading from GPS track data
            if (!video.duration || !routeGeoJSON || !routeGeoJSON.properties.headings) {
                return 0;  // Default if no heading data
            }
            
            const headings = routeGeoJSON.properties.headings;
            
            // Use timestamp-based indexing if available
            if (routeTimestamps && routeTimestamps.length > 0) {
                const gpsDuration = routeTimestamps[routeTimestamps.length - 1];
                const gpsTime = (video.currentTime / video.duration) * gpsDuration;
                
                for (let i = 0; i < routeTimestamps.length - 1; i++) {
                    if (gpsTime >= routeTimestamps[i] && gpsTime <= routeTimestamps[i + 1]) {
                        return headings[i] || 0;
                    }
                }
                return headings[headings.length - 1] || 0;
            } else {
                // Fallback to linear
                const progress = video.currentTime / video.duration;
                const index = Math.floor(progress * (headings.length - 1));
                return headings[index] || 0;
            }
        }
        
        function updateMarkerDistances() {
            const currentPos = getCurrentGPSPosition();
            if (!currentPos) return;
            
            markers3D.forEach((marker, idx) => {
                const distance = calculateDistance(
                    currentPos.lat, currentPos.lng,
                    marker.lat, marker.lng
                );
                
                // Update bearing from current position
                marker.bearing = calculateBearing(
                    currentPos.lat, currentPos.lng,
                    marker.lat, marker.lng
                );
                
                // Format distance
                if (distance < 1000) {
                    marker.distance = `${Math.round(distance)}m`;
                } else {
                    marker.distance = `${(distance / 1000).toFixed(1)}km`;
                }
            });
        }
        
        function create3DMarkers() {
            const container = document.getElementById('video-container');
            if (!container) {
                console.error('‚ùå Video container not found!');
                return;
            }
            
            markers3D.forEach(marker => {
                createSingleMarker(marker);
            });
            
            console.log(`‚úÖ Created ${markers3D.length} 3D markers in video`);
        }
        
        function showMarkerPopup(marker, markerEl) {
            // Remove existing popup
            const existing = document.querySelector('.marker-popup');
            if (existing) existing.remove();
            
            const icons = {
                hospital: '<path d="M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4v4z"/>',
                police: '<path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"/>',
                landmark: '<path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>'
            };
            
            const popup = document.createElement('div');
            popup.className = 'marker-popup';
            
            // Check if marker has Matterport link
            const matterportButton = marker.matterportUrl ? `
                <button class="matterport-btn" onclick="openMatterport('${marker.id}', '${marker.name}', '${marker.matterportUrl}')">
                    üè¢ View Interior (3D Tour)
                </button>
            ` : '';
            
            popup.innerHTML = `
                <button class="popup-close"></button>
                <div class="popup-header">
                    <div class="popup-icon ${marker.type}">
                        <svg viewBox="0 0 24 24">${icons[marker.type]}</svg>
                    </div>
                    ${marker.name}
                </div>
                <div class="popup-details">
                    ${marker.description}
                </div>
                <div class="popup-distance">
                    üìç ${marker.distance} from route
                </div>
                ${matterportButton}
                <button class="calibrate-btn" onclick="enterCalibrationMode('${marker.id}')">
                    üéØ Adjust Position
                </button>
            `;
            
            markerEl.appendChild(popup);
            
            // Close button
            popup.querySelector('.popup-close').addEventListener('click', (e) => {
                e.stopPropagation();
                popup.remove();
            });
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                }, { once: true });
            }, 100);
        }
        
        // ============================================
        // CALIBRATION MODE
        // ============================================
        
        let calibrationState = {
            active: false,
            markerId: null,
            originalOffset: 0,
            startX: 0
        };
        
        function enterCalibrationMode(markerId) {
            // Close any popups
            const existing = document.querySelector('.marker-popup');
            if (existing) existing.remove();
            
            // Pause video
            video.pause();
            
            // Find marker
            const markerElement = markerElements.find(m => m.data.id === markerId);
            if (!markerElement) return;
            
            // Activate calibration mode
            calibrationState.active = true;
            calibrationState.markerId = markerId;
            calibrationState.originalOffset = markerElement.data.calibratedOffset || 0;
            
            // Show banner
            document.getElementById('calibrationMode').classList.add('active');
            
            // Highlight marker
            markerElement.element.classList.add('calibrating');
            
            // Show toast
            showToast('Drag the marker left or right to adjust its position');
            
            // Disable camera rotation temporarily
            const container = document.getElementById('video-container');
            container.style.cursor = 'default';
            
            // Add drag handlers
            setupCalibrationDrag(markerElement);
        }
        
        function setupCalibrationDrag(markerElement) {
            const element = markerElement.element;
            const container = document.getElementById('video-container');
            let isDragging = false;
            let startClientX = 0;
            let startOffset = markerElement.data.calibratedOffset || 0;
            
            function onMouseDown(e) {
                e.stopPropagation();
                isDragging = true;
                startClientX = e.clientX;
                startOffset = markerElement.data.calibratedOffset || 0;
            }
            
            function onMouseMove(e) {
                if (!isDragging) return;
                
                // Calculate offset in degrees based on mouse movement
                const deltaX = e.clientX - startClientX;
                const containerWidth = container.getBoundingClientRect().width;
                const offsetDegrees = (deltaX / containerWidth) * 90; // 90 degrees for full width
                
                // Update marker's calibrated offset
                markerElement.data.calibratedOffset = startOffset + offsetDegrees;
                
                // Force marker position update
                update3DMarkerPositions();
            }
            
            function onMouseUp() {
                isDragging = false;
            }
            
            element.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            
            // Store handlers for cleanup
            calibrationState.handlers = { onMouseDown, onMouseMove, onMouseUp };
        }
        
        function saveCalibration() {
            if (!calibrationState.active) return;
            
            // Find the marker
            const markerElement = markerElements.find(m => m.data.id === calibrationState.markerId);
            if (markerElement) {
                // Save the calibrated offset
                const offset = markerElement.data.calibratedOffset || 0;
                
                // Update in markers3D array
                const marker = markers3D.find(m => m.id === calibrationState.markerId);
                if (marker) {
                    marker.calibratedOffset = offset;
                }
                
                // Save to localStorage
                saveCustomMarkers();
                
                showToast(`‚úÖ Position saved! Offset: ${offset.toFixed(1)}¬∞`);
            }
            
            exitCalibrationMode();
        }
        
        function cancelCalibration() {
            if (!calibrationState.active) return;
            
            // Restore original offset
            const markerElement = markerElements.find(m => m.data.id === calibrationState.markerId);
            if (markerElement) {
                markerElement.data.calibratedOffset = calibrationState.originalOffset;
                update3DMarkerPositions();
            }
            
            showToast('Calibration cancelled');
            exitCalibrationMode();
        }
        
        function exitCalibrationMode() {
            // Hide banner
            document.getElementById('calibrationMode').classList.remove('active');
            
            // Remove highlight
            const markerElement = markerElements.find(m => m.data.id === calibrationState.markerId);
            if (markerElement) {
                markerElement.element.classList.remove('calibrating');
                
                // Remove event listeners
                if (calibrationState.handlers) {
                    markerElement.element.removeEventListener('mousedown', calibrationState.handlers.onMouseDown);
                    document.removeEventListener('mousemove', calibrationState.handlers.onMouseMove);
                    document.removeEventListener('mouseup', calibrationState.handlers.onMouseUp);
                }
            }
            
            // Restore camera rotation
            const container = document.getElementById('video-container');
            container.style.cursor = 'grab';
            
            // Reset state
            calibrationState = {
                active: false,
                markerId: null,
                originalOffset: 0,
                startX: 0
            };
        }
        
        // Debug counter for periodic logging
        let markerUpdateDebugCounter = 0;
        
        function update3DMarkerPositions() {
            if (!camera) return;
            
            // Get current GPS position
            const currentPos = getCurrentGPSPosition();
            if (!currentPos) return;
            
            // Update distances and bearings based on current GPS position
            updateMarkerDistances();
            
            // Get vehicle heading from GPS track
            const vehicleHeading = getCurrentHeading();
            
            const container = document.getElementById('video-container');
            const containerRect = container.getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            // Debug log every 100 updates (~5 seconds at 20fps)
            markerUpdateDebugCounter++;
            const shouldDebugLog = markerUpdateDebugCounter % 100 === 0;
            
            if (shouldDebugLog) {
                console.log('üîÑ Marker Update:', {
                    totalMarkers: markerElements.length,
                    currentPos: `${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}`,
                    vehicleHeading: vehicleHeading.toFixed(1) + '¬∞',
                    cameraYaw: lon.toFixed(1) + '¬∞'
                });
            }
            
            let visibleCount = 0;
            let debugInfo = []; // For debug overlay
            
            markerElements.forEach(({ element, data }) => {
                // Calculate real-time distance from current position
                const distanceMeters = calculateDistance(
                    currentPos.lat, currentPos.lng,
                    data.lat, data.lng
                );
                
                // PROXIMITY CHECK: Only show if within 200 meters (better consumer experience)
                if (distanceMeters > 200) {
                    element.style.display = 'none';
                    element.style.opacity = '0';
                    return;
                }
                
                // Update the label with current distance and approach indicator
                const label = element.querySelector('.marker-label');
                if (label) {
                    const distText = distanceMeters < 1000 
                        ? `${Math.round(distanceMeters)}m` 
                        : `${(distanceMeters / 1000).toFixed(1)}km`;
                    
                    // Add approach indicator for better UX
                    let approachIcon = '';
                    if (distanceMeters < 50) {
                        approachIcon = 'üî• '; // Very close!
                    } else if (distanceMeters < 100) {
                        approachIcon = '‚ö° '; // Getting close
                    } else if (distanceMeters < 150) {
                        approachIcon = 'üëâ '; // Approaching
                    }
                    
                    label.textContent = `${approachIcon}${data.name} ‚Ä¢ ${distText}`;
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ACCURATE 360¬∞ MARKER POSITIONING
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Step 1: Calculate real-world bearing from current position to marker
                // (This gives us compass bearing: 0¬∞ = North, 90¬∞ = East, 180¬∞ = South, 270¬∞ = West)
                const markerBearing = calculateBearing(
                    currentPos.lat, currentPos.lng,
                    data.lat, data.lng
                );
                
                // Step 2: Calculate marker's position relative to vehicle direction
                // (If vehicle heads North and marker is East, relativeBearing = 90¬∞)
                let relativeBearing = markerBearing - vehicleHeading;
                
                // Normalize to -180 to 180 range (right is positive, left is negative)
                while (relativeBearing > 180) relativeBearing -= 360;
                while (relativeBearing < -180) relativeBearing += 360;
                
                // Step 3: Account for camera rotation (where user is looking)
                // lon: 0¬∞ = forward, 90¬∞ = looking right, -90¬∞ = looking left, 180¬∞ = looking back
                const cameraYaw = lon;
                
                // Final angle: marker position in screen space
                // This is the horizontal angle from screen center to marker
                let screenAngle = relativeBearing - cameraYaw;
                
                // Normalize again
                while (screenAngle > 180) screenAngle -= 360;
                while (screenAngle < -180) screenAngle += 360;
                
                // Apply calibration offset if exists
                if (data.calibratedOffset !== undefined) {
                    screenAngle += data.calibratedOffset;
                }
                
                // Collect debug info for all markers
                debugInfo.push({
                    name: data.name,
                    distance: distanceMeters.toFixed(0),
                    markerBearing: markerBearing.toFixed(1),
                    relativeBearing: relativeBearing.toFixed(1),
                    side: relativeBearing > 0 ? 'RIGHT' : 'LEFT',
                    screenAngle: screenAngle.toFixed(1),
                    isInView: isInView,
                    x: Math.round(x),
                    y: Math.round(y)
                });
                
                // Debug log for first marker every 100 updates
                if (shouldDebugLog && data.id === markers3D[0]?.id) {
                    console.log(`   Marker: ${data.name}`);
                    console.log(`     Compass Bearing: ${markerBearing.toFixed(1)}¬∞`);
                    console.log(`     Vehicle Heading: ${vehicleHeading.toFixed(1)}¬∞`);
                    console.log(`     Relative Bearing: ${relativeBearing.toFixed(1)}¬∞ (${relativeBearing > 0 ? 'RIGHT' : 'LEFT'})`);
                    console.log(`     Camera Yaw: ${cameraYaw.toFixed(1)}¬∞`);
                    console.log(`     Screen Angle: ${screenAngle.toFixed(1)}¬∞`);
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PROJECT TO SCREEN COORDINATES
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // For 360¬∞ video, horizontal position is directly based on angle
                // 75¬∞ FOV means ¬±37.5¬∞ is visible on screen
                const FOV = 75; // Three.js default camera FOV
                const halfFOV = FOV / 2;
                
                // Check if marker is within field of view
                const isInView = Math.abs(screenAngle) < 120; // ¬±120¬∞ for wider visibility
                
                // Calculate horizontal position
                // screenAngle of 0¬∞ = center, +FOV/2 = right edge, -FOV/2 = left edge
                const horizontalFraction = screenAngle / halfFOV;
                const x = centerX + (horizontalFraction * containerRect.width * 0.35); // 0.35 = scale factor
                
                // Vertical position (simplified, based on pitch)
                const cameraPitch = lat; // vertical camera angle
                const verticalOffset = Math.sin(cameraPitch * Math.PI / 180) * 50;
                const y = centerY - verticalOffset;
                
                // Calculate opacity based on angle (fade at edges)
                let opacity = 1.0;
                const angleDeg = Math.abs(adjustedBearing * 180 / Math.PI);
                if (angleDeg > 90) {
                    opacity = Math.max(0.3, 1 - (angleDeg - 90) / 30); // Fade beyond 90¬∞
                } else {
                    opacity = Math.max(0.5, Math.cos(adjustedBearing));
                }
                
                // Scale based on distance (closer = bigger)
                // Pop-up effect: small when far, big when close
                let scale;
                if (distanceMeters > 150) {
                    scale = 0.5; // Small when far
                } else if (distanceMeters > 100) {
                    scale = 0.7 + (150 - distanceMeters) / 150 * 0.3; // Growing
                } else if (distanceMeters > 50) {
                    scale = 1.0; // Full size
                } else {
                    scale = 1.0 + (50 - distanceMeters) / 50 * 0.2; // Even bigger when very close
                }
                
                if (isInView && x >= -200 && x <= containerRect.width + 200) {
                    // Smooth appearance
                    if (element.style.display === 'none') {
                    element.style.display = 'block';
                        element.style.animation = 'popIn 0.3s ease-out';
                    }
                    element.style.left = `${x}px`;
                    element.style.top = `${y}px`;
                    element.style.opacity = opacity;
                    element.style.transform = `scale(${scale})`;
                    visibleCount++;
                } else {
                    element.style.display = 'none';
                    element.style.opacity = '0';
                }
            });
            
            // Log visible markers count
            if (shouldDebugLog && markerElements.length > 0) {
                console.log(`   ${visibleCount}/${markerElements.length} markers visible in current view`);
            }
            
            // Update UI counter
            const markersTotalEl = document.getElementById('stat-markers-total');
            const markersVisibleEl = document.getElementById('stat-markers-visible');
            if (markersTotalEl) markersTotalEl.textContent = markerElements.length;
            if (markersVisibleEl) markersVisibleEl.textContent = visibleCount;
            
            // Update debug overlay
            const debugOverlay = document.getElementById('debugOverlay');
            const debugContent = document.getElementById('debugContent');
            if (debugOverlay && debugOverlay.style.display === 'block' && debugContent) {
                let html = `
                    <div style="color: #fff; margin-bottom: 8px;">
                        <strong>Camera:</strong> Yaw ${lon.toFixed(1)}¬∞, Pitch ${lat.toFixed(1)}¬∞<br>
                        <strong>Vehicle:</strong> Heading ${vehicleHeading.toFixed(1)}¬∞<br>
                        <strong>GPS:</strong> ${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}
                    </div>
                `;
                
                if (debugInfo.length > 0) {
                    html += `<div style="border-top: 1px solid #0ff; padding-top: 8px; margin-top: 8px;">`;
                    html += `<strong style="color: #fff;">Markers (${visibleCount}/${markerElements.length}):</strong><br><br>`;
                    debugInfo.forEach(info => {
                        const color = info.isInView ? '#0f0' : '#f80';
                        html += `
                            <div style="margin-bottom: 10px; padding: 5px; background: rgba(0,0,0,0.3); border-left: 2px solid ${color}; padding-left: 8px;">
                                <div style="color: ${color}; font-weight: bold;">${info.name}</div>
                                <div style="font-size: 10px; line-height: 1.4;">
                                    Distance: ${info.distance}m<br>
                                    Compass: ${info.markerBearing}¬∞<br>
                                    Relative: ${info.relativeBearing}¬∞ (${info.side})<br>
                                    Screen: ${info.screenAngle}¬∞<br>
                                    Position: (${info.x}, ${info.y})<br>
                                    ${info.isInView ? '<span style="color: #0f0">‚úÖ IN VIEW</span>' : '<span style="color: #f80">‚ö†Ô∏è OUT OF VIEW</span>'}
                                </div>
                            </div>
                        `;
                    });
                    html += `</div>`;
                } else {
                    html += `<div style="color: #888; margin-top: 8px;">No markers in range (200m)</div>`;
                }
                
                html += `<div style="border-top: 1px solid #0ff; padding-top: 8px; margin-top: 12px; color: #888; font-size: 10px;">Press 'D' to hide</div>`;
                
                debugContent.innerHTML = html;
            }
        }
        
        // Update markers on camera movement
        let markerUpdateInterval;
        
        function startMarkerUpdates() {
            markerUpdateInterval = setInterval(() => {
                update3DMarkerPositions();
                updateMapLandmarksVisibility(); // Keep map synced with video view
            }, 50); // 20fps
        }
        
        function stopMarkerUpdates() {
            if (markerUpdateInterval) {
                clearInterval(markerUpdateInterval);
            }
        }
        
        // ============================================
        // ADD LANDMARK SYSTEM
        // ============================================
        
        function openLandmarkModal() {
            const modal = document.getElementById('landmarkModal');
            const currentPos = getCurrentGPSPosition();
            const currentTime = video.currentTime;
            
            if (!currentPos) {
                showToast('Please wait for video to load');
                return;
            }
            
            // Populate form with current position info
            document.getElementById('formGPS').textContent = 
                `${currentPos.lat.toFixed(6)}, ${currentPos.lng.toFixed(6)}`;
            document.getElementById('formTime').textContent = formatTime(currentTime);
            
            // Clear form
            document.getElementById('landmarkName').value = '';
            document.getElementById('landmarkDesc').value = '';
            document.getElementById('landmarkType').value = 'landmark';
            document.getElementById('landmarkSide').value = 'right';
            
            modal.classList.add('show');
            
            // Focus on name input
            setTimeout(() => {
                document.getElementById('landmarkName').focus();
            }, 100);
        }
        
        function closeLandmarkModal() {
            const modal = document.getElementById('landmarkModal');
            modal.classList.remove('show');
        }
        
        function saveLandmark() {
            const name = document.getElementById('landmarkName').value.trim();
            const type = document.getElementById('landmarkType').value;
            const description = document.getElementById('landmarkDesc').value.trim();
            const side = document.getElementById('landmarkSide').value;
            
            if (!name) {
                showToast('Please enter a landmark name');
                return;
            }
            
            const currentPos = getCurrentGPSPosition();
            const currentTime = video.currentTime;
            
            // Calculate bearing based on side of road
            let bearingOffset = 0;
            if (side === 'right') bearingOffset = 90;
            else if (side === 'left') bearingOffset = -90;
            else bearingOffset = 0;
            
            // Create new marker
            const newMarker = {
                id: `custom_${Date.now()}`,
                type: type,
                name: name,
                description: description || `Added at ${formatTime(currentTime)}`,
                lat: currentPos.lat,
                lng: currentPos.lng,
                videoTime: currentTime,
                side: side,
                bearing: lon + bearingOffset  // Based on current camera direction
            };
            
            // Add to arrays
            markers3D.push(newMarker);
            customMarkers.push(newMarker);
            
            // Save to localStorage
            saveCustomMarkers();
            
            // Create marker element (3D in video)
            createSingleMarker(newMarker);
            
            // Add to map
            addSingleLandmarkToMap(newMarker);
            
            // Close modal
            closeLandmarkModal();
            
            // Show success
            showToast(`‚úÖ Landmark "${name}" added at ${formatTime(currentTime)}`);
            
            console.log('‚úÖ Added landmark:', newMarker);
        }
        
        function createSingleMarker(marker) {
            console.log(`   üéØ Creating 3D marker for: ${marker.name} (ID: ${marker.id})`);
            
            const container = document.getElementById('video-container');
            if (!container) {
                console.error('‚ùå Video container not found for marker:', marker.name);
                return;
            }
            
            // Check if marker already exists
            const existingMarker = document.getElementById(marker.id);
            if (existingMarker) {
                console.log(`   ‚ö†Ô∏è Marker ${marker.id} already exists, removing old one first`);
                existingMarker.remove();
            }
            
            const icons = {
                hospital: '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>',
                police: '<path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/>',
                landmark: '<path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zm0 18.5c-4.05-1.01-7-5.08-7-9.83V8.3l7-3.11 7 3.11v2.37c0 4.75-2.95 8.82-7 9.83z"/>',
                cafe: '<path d="M20 3H4v10c0 2.21 1.79 4 4 4h6c2.21 0 4-1.79 4-4v-3h2c1.11 0 2-.9 2-2V5c0-1.11-.89-2-2-2zm0 5h-2V5h2v3zM4 19h16v2H4z"/>'
            };
            
            const markerEl = document.createElement('div');
            markerEl.className = 'marker-3d';
            markerEl.id = marker.id;
            markerEl.style.display = 'none'; // Start hidden, will be shown by update function
            
            const icon = icons[marker.type] || icons.landmark;
            
            markerEl.innerHTML = `
                <div class="marker-pin">
                    <div class="marker-icon ${marker.type}">
                        <div class="marker-pulse"></div>
                        <svg viewBox="0 0 24 24">${icon}</svg>
                    </div>
                    <div class="marker-label">${marker.name}</div>
                </div>
            `;
            
            markerEl.addEventListener('click', (e) => {
                e.stopPropagation();
                showMarkerPopup(marker, markerEl);
            });
            
            container.appendChild(markerEl);
            markerElements.push({ element: markerEl, data: marker });
            
            console.log(`   ‚úÖ 3D marker created and added to DOM: ${marker.name}`);
            console.log(`   Total 3D marker elements: ${markerElements.length}`);
        }
        
        // Setup Add Landmark button
        function setupLandmarkSystem() {
            const addBtn = document.getElementById('addLandmarkBtn');
            if (addBtn) {
                addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    video.pause();  // Pause to mark location
                    openLandmarkModal();
                });
            }
            
            // Load saved landmarks
            loadCustomMarkers();
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // 'M' key: Add marker
                if (e.key === 'm' || e.key === 'M') {
                    const modal = document.getElementById('landmarkModal');
                    if (!modal.classList.contains('show')) {
                        openLandmarkModal();
                    }
                }
                
                // 'D' key: Toggle debug overlay
                if (e.key === 'd' || e.key === 'D') {
                    const debugOverlay = document.getElementById('debugOverlay');
                    if (debugOverlay.style.display === 'none' || !debugOverlay.style.display) {
                        debugOverlay.style.display = 'block';
                        showToast('Debug overlay enabled', 'info');
                    } else {
                        debugOverlay.style.display = 'none';
                        showToast('Debug overlay disabled', 'info');
                    }
                }
            });
        }
        
        // ============================================
        // VIDEO SEEKING FUNCTION
        // ============================================
        
        function seekVideo(percentage) {
            // Validate percentage
            if (isNaN(percentage) || percentage < 0 || percentage > 100) {
                console.error('‚ùå Invalid percentage:', percentage);
                console.trace('Stack trace for invalid percentage');
                showToast(`‚ùå Error: Invalid seek position (${percentage.toFixed(1)}%)`, 'error');
                return;
            }
            
            // Clamp to safe range
            percentage = Math.max(0, Math.min(100, percentage));
            
            // Check if video element exists
            if (!video) {
                console.error('Video element not found');
                showToast('Error: Video not initialized');
                return;
            }
            
            // Check if video duration is valid
            if (!video.duration || isNaN(video.duration) || video.duration === 0) {
                console.warn('Video not ready. Duration:', video.duration, 'Ready state:', video.readyState);
                showToast('Video not ready. Please wait...');
                
                // Try to load the video if it hasn't started
                if (video.readyState === 0) {
                    video.load();
                }
                
                // Wait for metadata to load, then try again
                video.addEventListener('loadedmetadata', function retrySeek() {
                    video.removeEventListener('loadedmetadata', retrySeek);
                    console.log('Video metadata loaded. Retrying seek...');
                    seekVideo(percentage);
                }, { once: true });
                
                return;
            }
            
            // Calculate seek time
            const seekTime = (percentage / 100) * video.duration;
            
            // Validate seek time
            if (isNaN(seekTime) || seekTime < 0 || seekTime > video.duration) {
                console.error('Invalid seek time:', seekTime, 'Duration:', video.duration);
                showToast('Error: Invalid timestamp');
                return;
            }
            
            console.log(`Seeking to ${percentage.toFixed(1)}% = ${seekTime.toFixed(2)}s (Duration: ${video.duration.toFixed(2)}s)`);
            
            // Check if video can seek (readyState >= 2 means HAVE_CURRENT_DATA or better)
            if (video.readyState >= 2) {
                // Video is ready, seek immediately
                performSeek(seekTime, percentage);
            } else {
                // Wait for video to be ready
                console.log('Waiting for video to be ready... Current readyState:', video.readyState);
                showToast('Loading video data...');
                
                video.addEventListener('canplay', function canSeek() {
                    video.removeEventListener('canplay', canSeek);
                    console.log('Video ready. Seeking now...');
                    performSeek(seekTime, percentage);
                }, { once: true });
                
                // Force load if not started
                if (video.readyState === 0) {
                    video.load();
                }
            }
        }
        
        function performSeek(seekTime, percentage) {
            try {
                // Store current play state
                const wasPlaying = !video.paused;
                
                // Perform the seek
                video.currentTime = seekTime;
                
                // Show feedback
                showToast(`üé¨ Jumped to ${percentage.toFixed(1)}% (${formatTime(seekTime)})`, 'success');
                console.log('‚úÖ Seek successful. New currentTime:', video.currentTime);
                
                // If video was playing, ensure it continues (some browsers pause on seek)
                if (wasPlaying) {
                    video.play().catch(err => {
                        console.warn('Auto-play after seek failed:', err);
                    });
                }
                
                // Verify seek worked after a brief delay
                setTimeout(() => {
                    const actualTime = video.currentTime;
                    const timeDiff = Math.abs(actualTime - seekTime);
                    
                    if (timeDiff > 1.0) {
                        console.warn(`Seek verification failed. Expected: ${seekTime.toFixed(2)}s, Actual: ${actualTime.toFixed(2)}s, Diff: ${timeDiff.toFixed(2)}s`);
                        
                        // Try one more time
                        video.currentTime = seekTime;
                    } else {
                        console.log('Seek verified successfully.');
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error during seek:', error);
                showToast('Error seeking video');
            }
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds)) return '00:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            
            // Remove existing type classes
            toast.classList.remove('toast-success', 'toast-error', 'toast-warning', 'toast-info');
            
            // Add appropriate type class
            switch(type) {
                case 'success':
                    toast.classList.add('toast-success');
                    break;
                case 'error':
                    toast.classList.add('toast-error');
                    break;
                case 'warning':
                    toast.classList.add('toast-warning');
                    break;
                default:
                    toast.classList.add('toast-info');
            }
            
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }
        
        // ============================================
        // CLEAR ALL TAGS
        // ============================================
        
        function clearAllTags() {
            if (!confirm('‚ö†Ô∏è Clear all tagged landmarks?\n\nThis will remove:\n- All 3D markers from video\n- All markers from map\n- All saved tags from localStorage\n\nThis action cannot be undone!')) {
                return;
            }
            
            console.log('üóëÔ∏è Clearing all tags...');
            
            // Remove 3D markers from video
            markerElements.forEach(({ element }) => {
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            markerElements.length = 0;
            
            // Remove markers from map
            mapLandmarkMarkers.forEach(({ leafletMarker }) => {
                if (leafletMarker) {
                    map.removeLayer(leafletMarker);
                }
            });
            mapLandmarkMarkers.length = 0;
            
            // Clear data arrays completely
            markers3D.length = 0;
            customMarkers.length = 0;
            
            // Clear localStorage
            localStorage.removeItem('customMarkers');
            
            // Update tag count
            updateTagCount();
            
            // Show success message
            showToast('‚úÖ All tags cleared! Map and video reset.');
            console.log('‚úÖ All tags cleared successfully');
        }
        
        // ============================================
        // AUTO-TAG LANDMARKS FROM OPENSTREETMAP
        // ============================================
        
        async function autoTagLandmarks() {
            const btn = document.getElementById('autoTagBtn');
            btn.disabled = true;
            
            // Show progress messages
            const progressMessages = [
                'üîç Analyzing route...',
                'üì° Connecting to OpenStreetMap...',
                'üè¢ Searching for landmarks...',
                'üìç Processing locations...'
            ];
            
            let messageIndex = 0;
            btn.innerHTML = `<span>${progressMessages[0]}</span>`;
            
            // Update message every 3 seconds
            const progressInterval = setInterval(() => {
                messageIndex = (messageIndex + 1) % progressMessages.length;
                if (btn.disabled) {
                    btn.innerHTML = `<span>${progressMessages[messageIndex]}</span>`;
                }
            }, 3000);
            
            showToast('üîç Querying OpenStreetMap for landmarks... (may take 10-30 seconds)');
            
            try {
                // Get route bounds
                const coords = routeGeoJSON.geometry.coordinates;
                const lats = coords.map(c => c[1]);
                const lngs = coords.map(c => c[0]);
                
                const minLat = Math.min(...lats);
                const maxLat = Math.max(...lats);
                const minLon = Math.min(...lngs);
                const maxLon = Math.max(...lngs);
                
                // Expand bounds slightly (100 meters buffer)
                const buffer = 0.001; // ~100 meters
                const bbox = `${minLat - buffer},${minLon - buffer},${maxLat + buffer},${maxLon + buffer}`;
                
                // Query ONLY named buildings (what you see on the map tiles)
                // This matches exactly what OpenStreetMap tiles show
                const query = `
                [out:json][timeout:30];
                (
                  way["building"]["name"](${bbox});
                  node["building"]["name"](${bbox});
                );
                out center;
                `;
                
                console.log('üîç Querying Overpass API...');
                
                // Try multiple Overpass API servers (they can be slow/busy)
                const overpassServers = [
                    'https://overpass.kumi.systems/api/interpreter',  // Usually faster
                    'https://overpass-api.de/api/interpreter',         // Official
                    'https://overpass.openstreetmap.ru/api/interpreter' // Russian mirror
                ];
                
                let response = null;
                let lastError = null;
                
                // Try each server with timeout
                for (let i = 0; i < overpassServers.length; i++) {
                    const server = overpassServers[i];
                    console.log(`Trying server ${i + 1}/${overpassServers.length}: ${server}`);
                    
                    try {
                        // Add timeout to fetch (30 seconds)
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 30000);
                        
                        response = await fetch(server, {
                            method: 'POST',
                            body: query,
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            console.log(`‚úÖ Success with server ${i + 1}`);
                            break;
                        } else {
                            console.warn(`Server ${i + 1} returned ${response.status}`);
                            lastError = new Error(`HTTP ${response.status}`);
                        }
                    } catch (error) {
                        console.warn(`Server ${i + 1} failed:`, error.message);
                        lastError = error;
                        
                        if (i < overpassServers.length - 1) {
                            showToast(`Server ${i + 1} busy, trying alternative...`);
                            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
                        }
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error(`All Overpass servers failed. Last error: ${lastError?.message || 'Unknown'}`);
                }
                
                const data = await response.json();
                console.log(`‚úÖ Found ${data.elements.length} POIs from OpenStreetMap`);
                
                // Filter and convert to landmarks
                const newLandmarks = [];
                let skipped = 0;
                
                for (const element of data.elements) {
                    // Skip if no name
                    if (!element.tags || !element.tags.name) {
                        skipped++;
                        continue;
                    }
                    
                    // Get coordinates (handle both nodes and ways)
                    let lat, lon;
                    if (element.type === 'node') {
                        lat = element.lat;
                        lon = element.lon;
                    } else if (element.center) {
                        lat = element.center.lat;
                        lon = element.center.lon;
                    } else {
                        skipped++;
                        continue;
                    }
                    
                    // Check if already exists
                    const exists = markers3D.some(m => 
                        m.name === element.tags.name && 
                        Math.abs(m.lat - lat) < 0.0001
                    );
                    
                    if (exists) {
                        skipped++;
                        continue;
                    }
                    
                    // Determine type based on building/amenity
                    let type = 'landmark';
                    let description = element.tags.building || 'Building';
                    
                    // Check for specific amenities
                    if (element.tags.amenity === 'hospital' || element.tags.building === 'hospital') {
                        type = 'hospital';
                        description = 'Hospital';
                    } else if (element.tags.amenity === 'police') {
                        type = 'police';
                        description = 'Police Station';
                    } else if (element.tags.amenity === 'cafe' || element.tags.amenity === 'restaurant') {
                        type = 'cafe';
                        description = element.tags.cuisine || element.tags.amenity || 'Food & Beverage';
                    } else if (element.tags.building === 'commercial') {
                        description = 'Commercial Building';
                    } else if (element.tags.building === 'residential') {
                        description = 'Residential Building';
                    } else if (element.tags.building === 'retail') {
                        description = 'Retail Building';
                    } else if (element.tags.shop) {
                        description = element.tags.shop.charAt(0).toUpperCase() + element.tags.shop.slice(1);
                    }
                    
                    // Calculate nearest point on route
                    const poiPoint = turf.point([lon, lat]);
                    const nearestPoint = turf.nearestPointOnLine(routeGeoJSON, poiPoint, { units: 'meters' });
                    const distance = nearestPoint.properties.dist;
                    
                    // Only include if within 150 meters of route
                    if (distance > 150) {
                        skipped++;
                        continue;
                    }
                    
                    // Calculate video timestamp
                    const distanceFromStart = nearestPoint.properties.location * totalRouteLength;
                    const videoTime = (distanceFromStart / totalRouteLength) * video.duration;
                    
                    // Calculate bearing
                    const nearestCoords = nearestPoint.geometry.coordinates;
                    const bearing = calculateBearing(
                        nearestCoords[1], nearestCoords[0],
                        lat, lon
                    );
                    
                    // Determine side
                    const vehicleHeading = routeGeoJSON.properties.headings[
                        Math.floor(nearestPoint.properties.location * routeGeoJSON.properties.headings.length)
                    ] || 0;
                    
                    let relativeBearing = bearing - vehicleHeading;
                    while (relativeBearing > 180) relativeBearing -= 360;
                    while (relativeBearing < -180) relativeBearing += 360;
                    
                    const side = relativeBearing > 0 ? 'right' : 'left';
                    
                    // Create landmark
                    const landmark = {
                        id: `osm_${element.type}_${element.id}`,
                        type: type,
                        name: element.tags.name,
                        description: description,
                        lat: lat,
                        lng: lon,
                        bearing: bearing,
                        videoTime: videoTime,
                        side: side,
                        distance: Math.round(distance),
                        source: 'OpenStreetMap',
                        tags: element.tags
                    };
                    
                    newLandmarks.push(landmark);
                }
                
                console.log(`‚úÖ Created ${newLandmarks.length} landmarks (skipped ${skipped})`);
                
                if (newLandmarks.length === 0) {
                    showToast('‚ö†Ô∏è No new landmarks found along route');
                    btn.disabled = false;
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg><span>Auto-Tag POIs</span>';
                    return;
                }
                
                // Add all landmarks
                for (const landmark of newLandmarks) {
                    markers3D.push(landmark);
                    createSingleMarker(landmark);
                    addSingleLandmarkToMap(landmark);
                }
                
                // Save to storage
                customMarkers.push(...newLandmarks);
                saveCustomMarkers();
                
                showToast(`‚úÖ Added ${newLandmarks.length} landmarks automatically!`);
                
                // Show summary modal
                showAutoTagSummary(newLandmarks);
                
            } catch (error) {
                console.error('‚ùå Auto-tag error:', error);
                
                // Show helpful error message based on error type
                let errorMsg = '‚ùå Auto-tagging failed. ';
                
                if (error.message.includes('timeout') || error.message.includes('abort')) {
                    errorMsg += 'Servers are busy. Try again in a minute or use manual tagging.';
                } else if (error.message.includes('Network')) {
                    errorMsg += 'Check your internet connection.';
                } else if (error.message.includes('All Overpass servers failed')) {
                    errorMsg += 'All servers are down. Use manual tagging (green button) instead.';
                } else {
                    errorMsg += 'Please try again or tag manually.';
                }
                
                showToast(errorMsg);
                
                // Show fallback instructions
                setTimeout(() => {
                    if (confirm('Auto-tagging failed. Would you like to see manual tagging instructions?')) {
                        alert(`Manual Tagging Steps:
                        
1. Play the video
2. When you see a landmark, pause
3. Press 'M' or click green "Add Landmark" button
4. Fill in the form:
   - Name: Building name
   - Type: Select category
   - Side: Left/Right/Center
5. Click "Add Landmark"

Or wait a minute and try "Auto-Tag" again (servers may be busy).`);
                    }
                }, 1000);
            } finally {
                clearInterval(progressInterval);
                btn.disabled = false;
                btn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg><span>Auto-Tag POIs</span>';
            }
        }
        
        function showAutoTagSummary(landmarks) {
            // Show simple success message
            const message = `‚úÖ Tagged ${landmarks.length} building${landmarks.length !== 1 ? 's' : ''} from OpenStreetMap!`;
            showToast(message);
            
            // Log details to console
            console.log('üìä Auto-Tag Summary:');
            console.log(`   Total Buildings: ${landmarks.length}`);
            landmarks.forEach((l, i) => {
                console.log(`   ${i + 1}. ${l.name} (${l.description})`);
            });
        }
        
        // ============================================
        // INITIALIZE APPLICATION
        // ============================================
        
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Loading Insta360 X5 Street View...');
            
            // Load GPS data first
            await loadGPSData();
            
            // Then initialize map and video
            initMap();
            init360Video();
            setupVideoControls();
            setupLandmarkSystem();
            
            // Setup clear tags button
            const clearTagsBtn = document.getElementById('clearTagsBtn');
            if (clearTagsBtn) {
                clearTagsBtn.addEventListener('click', clearAllTags);
            }
            
            console.log('‚úÖ Application ready!');
            console.log('');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìñ HOW TO USE:');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üõ£Ô∏è  Click the GREEN ROUTE LINE ‚Üí Jump to that video frame');
            console.log('üè¢ Click a BUILDING on map ‚Üí Auto-tag it (appears in video)');
            console.log('‚å®Ô∏è  Hold SHIFT + Click ‚Üí Manually name a location');
            console.log('üîç Type debugMarkers() ‚Üí Check marker status');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('');
        });
    </script>
</body>
</html>
